<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Anon by pkholland</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Anon</h1>
        <h2>Experiments in Web Services Design</h2>
        <a href="https://github.com/pkholland/anon" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

<h1>
<a id="tech-overview" class="anchor" href="#tech-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Anon Technical Overview</h2>

<ul>Table of Contents:
<li><a href="#io_concur">Fibers and I/O Driven Concurency with epoll</a></li>
<li>EAGAIN Propogation</li>
<li>The look of the API</li>
</ul>

<h2>
<a id="io_concur" class="anchor" href="#io_concur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fibers and I/O Driven Concurrency</h2>

<p>
The story here starts at linux's 'epoll' api and how it supports efficient delivery of i/o notification.
In the epoll model an application can register a set of file descriptors with the kernel, and with each
one specify two pieces of data:

<ul>
<li>What i/o "events" it wants to be notified about</li>
<li>A pointer that it wants to given when an i/o event occurs for that file descriptor</li>
</ul>

Linux uses file descriptors to represent lots of different things, but from a web services perspective
the most important and typical one is that network sockets are represented with file descriptors.
A reasonable picture of what is going on with epoll is here:
</p>

<p><img src="epoll.svg?raw=true" alt="Linux epoll picture"></p>

<p>
Because Linux will store pointers for you associated with each file descriptor, you can use these pointers
any way you want, and like this example, you can use them to represent the addresses of C++ class instances
that could be the piece of code you want to run whenever it is possible to read, or even write, to a
file <em>without blocking</em>.
</p>

<p>Consider the following pseudo-code:</p>

<div class="highlight highlight-C++"><pre>
<span class="c1">// runs forever...</span>
<span class="kt">void</span> <span class="nf">epoll_loop</span>()
{
  <span class="k">while</span> (<span class="kc">true</span>) {
    my_epoll_result = <span class="nf">epoll_wait</span>();
    the_object = (<span class="kc">base_class</span>*)my_epoll_result;
    the_object->handle_io();
  }
}
</pre></div>

<p>
In this sort of model, if <code>epoll_wait</code> comes back with the 'result' that represents file descriptor
48 in the picture above, then a simple virtual function call can get us to the code that knows what to do
when 'another.server.com' has sent information to us that we can read without blocking.
</p>

</p>
In a number of ways Linux's <code>epoll_wait</code> acts like both <code>poll</code> and <code>select</code>
except for a few important differences.  First, and most importantly, with epoll you don't have to send the
set of file descriptors you are interested in each time you call the function (as you do with both poll
and select).  This means that the kernel doesn't have to read the set you are telling it on each call and
figure out what to do with each of them.  This can make an enormous difference when you have a lot of file
descriptors that you are interested in -- as is frequently the case for a web service that is under load.
It's also more convenient to let the kernel associate the file descriptors and pointers for you, then you
having to do it by hand.
</p>

<p>
A last important difference that is largely just a consequence of the first one (not needing to specify
the file set on each call), is that it is now fairly straight forward to have multiple threads all waiting for
epoll io notification on the same file set.  This can further reduce the processing time needed to go from
event notification to your handling code in the case of you having multi-threaded event handling code.
In anon's epoll model, it calls epoll_wait on the same file set using multiple threads, and so can
dispatch to the handling code directly using (virtual) function calls as is shown in the code snippet
above.  These handlers simply execute in the thread that recieved the notification from the os.
</p>

<h3>
<a id="callback_design" class="anchor" href="#callback_deskgn" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Callback Oriented" Design</h2>

<p>
A significant drawback to this sort of epoll code is that while it is very efficient at notifying you
that you can read some data from a socket, it can't tell you whether you can read <em>all</em> the data
you might be interested in.  It could be that a server has responded with only some of the information it
is going to send you, and you are likely to need to start reading what it has sent to even determine
whether it has sent you a complete reply or not.
</p>

<p>
If the code that you start running when epoll tells you that you can read some data begins parsing the
http header fields of a reply, and part way through parsing this you get to the end of what the server
sent in its first network packet, then your parsing code either will cause the next <code>read</code>
operation on the socket to block until the next network packet shows up, or you need to write your http
parser in such a way that it can be suspended and resumed later on when the packet does show up and you
get the next epoll notification for it.
</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/pkholland/anon/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/pkholland/anon/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/pkholland/anon"></a> is maintained by <a href="https://github.com/pkholland">pkholland</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>

