<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Anon by pkholland</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Anon</h1>
        <h2>Experiments in Web Services Design</h2>
        <a href="https://github.com/pkholland/anon" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
        

<h1>
<a id="tech-overview" class="anchor" href="#tech-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>More Fun Timing Data
</h1>


<p>
It is, admittedly, a little unrealistic to just examine how quickly simple i/o dispatching happens
in different designs if you are interested in how well an overall service will perform.  So what about
other operations that might be interesting to look into?  This page looks at a couple of others.
</p>

<ul>
  <li><a href="#context_create">Context Creation and Destruction</a></li>
  <li><a href="#full_on_http">Full-on http API servers</a></li>
</ul>

<h2>
<a id="context_create" class="anchor" href="#context_create" aria-hidden="true"><span class="octicon octicon-link"></span></a>Context Creation and Destruction
</h2>

<p>
A common point at which new "execution contexts" need to be created, or at least fetched from a
pool of previously constructed ones, is at the point when a new connection request comes into the server.
So, in the following sort of code:
</p>

<div class="highlight highlight-C++"><pre>
<span class="c1">// accept loop</span>
<span class="kt">void</span> <span class="nf">accept_loop</span>(<span class="k">int</span> listening_socket)
{
  <span class="k">while</span> (<span class="kc">true</span>) {
    <span class="kt">int</span> new_connection = <span class="nf">accept</span>(listening_socket, <span class="m">0</span>, <span class="m">0</span>);
    
    <span class="c1">// create a new "context" to handle this connection</span>
    std::thread(std::bind(<span class="nf">handle_message</span>, new_connection)).<span class="nf">detach</span>();
  }
}
</pre></div>

<p>
you can have code that creates a new thread, as shown in the code above, or you can do something else.
Regardless of what you do, you will need some kind of context-like object that keeps track of the state
of things as you process the messages you are going to receive.
</p>

<p>
Independent of whether you construct new objects or pool them, it is interesting to understand the cost
of constructing new ones - since you will need to do this with some frequency.  So here is some data on
the cost of constructing new OS threads, as shown above, and then running an empty function in that context.
That is, simply waiting for all created contexts to exit.  This is done for OS threads vs. anon fibers.
</p>

<p>
<table style="width:100%">
  <caption><b>Time to create and execute 10,000 threads vs. fibers</b></caption>
  <tr>
    <td></td>
    <td><b>1 Core</b></td>
    <td><b>2 Cores</b></td>
    <td><b>4 Cores</b></td>
  </tr>
  <tr>
    <td><b>Fibers</b></td>
    <td>0.022 - 0.022 secs.</td>
    <td>0.023 - 0.024 secs.</td>
    <td>0.031 - 0.033 secs.</td>
  </tr>
  <tr>
    <td><b>OS Threads</b></td>
    <td>0.175 - 0.256 secs.</td>
    <td>0.410 - 0.600 secs.</td>
    <td>0.385 - 0.409 secs.</td>
  </tr>
</table>
</p>

<p>
Again, this data shows some penalty to running with multiple cores.  But in general the fiber case
is normally significantly faster than the OS thread case - approximately one order of magnitude faster.
</p>

<h2>
<a id="full_on_http" class="anchor" href="#full_on_http" aria-hidden="true"><span class="octicon octicon-link"></span></a>Full-on Http API Servers
</h2>

<p>
Testing fully-functional Http parsers is both more interesting and more dangerous.  It is more interesting
because it is getting closer to meaningful when considering different server designs.  But the performance
of them can be affected by <em>lots</em> of different aspects of exactly what was tested.  For this, it is
probably best to not speculate too much about what the causes of the differences are, but to just be careful
in listing exactly what was tested.
</p>

<p>
The goal here will be to try to implement a very similar server in several different environments and test
it with the same code.  The tables will just show the performance numbers for each test.  To start with here
is a basic description of the test code that is used on each server:
</p>

<div class="highlight highlight-C++"><pre>
<span class="kt">void</span> <span class="nf">http_client</span>()
{
  <span class="kt">int</span> socks[400];
  <span class="k">for</span> (<span class="kt">int</span> i=0; i<400; i++)
    socks[i] = <span class="nf">connect</span>( ... to the server ... );
    
  <span class="c1">// a simple HTTP GET string...</span> 
  <span class="k">const</span> <span class="kt">char</span>* http_GET_message = "GET / HTTP/1.1\r\nHost: ...";
    
  <span class="k">for</span> (<span class="kt">int</span> msg=0; i<10000; msg++) {
  
    <span class="c1">// send http string to the server</span>
    <span class="k">for</span> (<span class="kt">int</span> i=0; i<400; msg++)
      <span class="nf">send_string</span>(socks[i], http_GET_message);
      
    <span class="c1">// now loop through and read all the responses</span>
    <span class="k">for</span> (<span class="kt">int</span> i=0; i<400; msg++)
      <span class="nf">read_http_response</span>(socks[i]);
  }
}
</pre></div>

<p>
Like other tests, this test code takes care to send the http get requests to lots of different sockets
before attempting to read responses from any of them to force the server to perform context switches
form one connection to another.  But it is also trying to avoid performing operations like constructing
custom GET messages for each request.  While not explicily shown in this example, it also does only minimal
parsing of the response message.  Also not really shown, but the client uses keep-alive strategies for the
connection to avoid timing the process of the connect itself.  This sort of test is trying to only ensure
that the server is switching connections and parsing the http request prior to sending its reply.
</p>

<p>
What follows is the look of the source for these simple "echo" servers written in the differnt tool
sets that are timed.  Following that is the table listing the timings.
</p>

<h4>
The Anon Example
</h4>

<p>
The anon example gets to use anon-style syntax and looks like this.  The <b>http_server</b> class is
one provided by anon, and its constructor takes a callable function that is called - in a fiber - each
time a new connection is established from a client.  The style of its API is inspired by the node.js
syntax for this.  In this example it simply specifies that it will be returning plain text, and then
writes "echo server!" into the body of the reply.
</p>

<div class="highlight highlight-C++"><pre>
<span class="kt">http_server</span> my_http(/*port*/8080,
    [](<span class="kc">const</span> <span class="kt">http_request</span>& request, <span class="kt">http_reply</span>& reply){
      reply.<span class="nf">add_header</span>(<span class="s2">&quot;Content-Type&quot;</span>, <span class="s2">&quot;text/plain&quot;</span>);
      reply &lt;&lt; <span class="s2">&quot;echo server!\n&quot;</span>;
    });
</pre></div>

<h4>
The Node.js Example
</h4>

<p>
The node.js example is visually very similar to the anon one.  It makes use of syntax that lets it pass
a function as a parameter to an http server.  That service calls the supplied function when new connections
arive, and it is the function that writes the response information.  But in this case the lauguage is javascript,
not C++
</p>

<div class="highlight highlight-C++"><pre>
my_http = <span class="nf">require</span>(<span class="s2">&quot;http&quot;</span>);
my_http.<span class="nf">createServer</span>(<span class="kc">function</span>(request,response){
  response.<span class="nf">writeHeader</span>(200, {<span class="s2">&quot;Content-Type&quot;</span>: <span class="s2">&quot;text/plain&quot;</span>});
  response.<span class="nf">write</span>(<span class="s2">&quot;echo server!&quot;</span>);
  response.<span class="nf">end</span>();
}).<span class="nf">listen</span>(/*port*/8080); 
</pre></div>

<h4>
The Proxygen Example
</h4>

<p>
Unfortunately, the proxygen example is a little too complicated to show in a short snippet like the anon
and node.js examples.  However, it is just the standard "echo" server that comes with proxygen github project
and the one that they talk about in their discussions.
</p>

<h4>
The Comparison
</h4>

<p>
This test is measured in "messages per second" as seen by the client application.  Like in other tests
the client application is running on the same machine as the server, and so is using the loopback network
address to connect to and communicate with the server.
</p>

<p>
<table style="width:100%">
  <caption><b>Messages Per Second</b></caption>
  <tr>
    <td></td>
    <td><b>1 Core</b></td>
    <td><b>2 Cores</b></td>
    <td><b>4 Cores</b></td>
  </tr>
  <tr>
    <td><b>Anon</b></td>
    <td>107,000 </td>
    <td>177,000</td>
    <td>254,000</td>
  </tr>
  <tr>
    <td><b>Proxygen</b></td>
    <td>40,000</td>
    <td>75,000</td>
    <td>139,000</td>
  </tr>
  <tr>
    <td><b>Node.js</b></td>
    <td>3,700</td>
    <td>3,700</td>
    <td>3,700</td>
  </tr>
</table>
</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/pkholland/anon/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/pkholland/anon/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/pkholland/anon"></a> is maintained by <a href="https://github.com/pkholland">pkholland</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
