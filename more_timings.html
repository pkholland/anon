<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Anon by pkholland</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Anon</h1>
        <h2>Experiments in Web Services Design</h2>
        <a href="https://github.com/pkholland/anon" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
        

<h1>
<a id="tech-overview" class="anchor" href="#tech-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>More Fun Timing Data
</h1>


<p>
It is, admittedly, a little unrealistic to just examine how quickly simple
<a href="tech_overview.html#fiber_timing_data">i/o dispatching</a> happens
in different designs if you are interested in how well an overall service will perform.  So what about
other operations that might be interesting to look into?  This page looks at a couple of others.
</p>

<ul>
  <li><a href="#context_create">Context Creation and Destruction</a></li>
  <li><a href="#full_on_http">Full-on Http API servers</a></li>
</ul>

<h2>
<a id="context_create" class="anchor" href="#context_create" aria-hidden="true"><span class="octicon octicon-link"></span></a>Context Creation and Destruction
</h2>

<p>
A common point at which new "execution contexts" need to be created, or at least fetched from a
pool of previously constructed ones, is at the point when a new connection request comes into the server.
So, in the following sort of code:
</p>

<div class="highlight highlight-C++"><pre>
<span class="c1">// accept loop</span>
<span class="kt">void</span> <span class="nf">accept_loop</span>(<span class="k">int</span> listening_socket)
{
  <span class="k">while</span> (<span class="kc">true</span>) {
    <span class="kt">int</span> new_connection = <span class="nf">accept</span>(listening_socket, <span class="m">0</span>, <span class="m">0</span>);
    
    <span class="c1">// create a new "context" to handle this connection</span>
    std::thread(std::bind(<span class="nf">handle_message</span>, new_connection)).<span class="nf">detach</span>();
  }
}
</pre></div>

<p>
you can have code that creates a new thread, as shown in the code above, or you can do something else.
Regardless of what you do, you will need some kind of context-like object that keeps track of the state
of things as you process the messages you are going to receive.
</p>

<p>
Independent of whether you always construct new objects or pool them, it is interesting to understand the cost
of constructing new ones - since you will need to do this with some frequency.  To time this kind of data we want to
minimize the work being done inside the context (thread) so we can just look at creation and destruction time.
So timing the OS thread case would be running a piece of code something like:
</p>

<div class="highlight highlight-C++"><pre>
<span class="c1">// create lots of threads and wait for them to finish</span>
<span class="kt">void</span> <span class="nf">time_threads</span>()
{
  std::vector&lt;std::thread&gt; threads;
  
  <span class="k">for</span> (<span class="k">int</span> i=<span class="m">0</span>; i&lt;<span class="m">10000</span>; i++)
    threads.<span class="nf">push_back</span>(std::thread([]{return <span class="m">0</span>;});
    
  <span class="k">for</span> (<span class="k">int</span> i=<span class="m">0</span>; i&lt;<span class="m">10000</span>; i++)
    threads[i].<span class="nf">join</span>();
}
</pre></div>

<p>
Fibers support similar syntax so we can write the fiber equivalent of this loop and time both of them.  Here
is the timing data when this code is run on 1, 2, and 4 core linux VMs, hosted on a 2.3 GHz MacBook Pro.
</p>

<p>
<table style="width:100%">
  <caption><b>Time to create and execute 10,000 fibers vs. 10,000 OS threads</b></caption>
  <tr>
    <td></td>
    <td><b>1 Core</b></td>
    <td><b>2 Cores</b></td>
    <td><b>4 Cores</b></td>
  </tr>
  <tr>
    <td><b>Fibers</b></td>
    <td>0.022 - 0.022 secs.</td>
    <td>0.023 - 0.024 secs.</td>
    <td>0.031 - 0.033 secs.</td>
  </tr>
  <tr>
    <td><b>OS Threads</b></td>
    <td>0.175 - 0.256 secs.</td>
    <td>0.410 - 0.600 secs.</td>
    <td>0.385 - 0.409 secs.</td>
  </tr>
</table>
</p>

<p>
Again, this data shows some penalty to running with multiple cores.  But in general the fiber case
is significantly faster than the OS thread case by about one order of magnitude.
</p>

<h2>
<a id="full_on_http" class="anchor" href="#full_on_http" aria-hidden="true"><span class="octicon octicon-link"></span></a>Full-on Http API Servers
</h2>

<p>
Testing fully-functional Http servers is both more interesting and more dangerous.  It is more interesting
because it is getting closer to meaningful when considering different server designs.  But the performance
of them can be affected by <em>lots</em> of different aspects of exactly what was tested.  For this, it is
probably best to not speculate too much about what the causes of the differences are, but to just be careful
in describing exactly what is being tested.
</p>

<p>
The goal here will be to try to implement very similar servers in several different environments and test
them with the same client code.  The tables will just show the performance numbers for each test.  To start with here
is a basic description of the test code that is used to drive each server:
</p>

<div class="highlight highlight-C++"><pre>
<span class="kt">void</span> <span class="nf">http_client</span>()
{
  <span class="kt">int</span> socks[400];
  <span class="k">for</span> (<span class="kt">int</span> i=<span class="m">0</span>; i&lt;<span class="m">400</span>; i++)
    socks[i] = <span class="nf">connect</span>( ... to the server ... );
    
  <span class="c1">// a simple HTTP GET string...</span> 
  <span class="c1">// be sure to specify keep-alive...</span> 
  <span class="k">const</span> <span class="kt">char</span>* http_GET_message = "GET / HTTP/1.1\r\nHost: ...";
    
  <span class="k">for</span> (<span class="kt">int</span> msg=<span class="m">0</span>; msg&lt;<span class="m">2000</span>; msg++) {
  
    <span class="c1">// send http string to the server</span>
    <span class="k">for</span> (<span class="kt">int</span> i=<span class="m">0</span>; i&lt;<span class="m">400</span>; i++)
      <span class="nf">send_string</span>(socks[i], http_GET_message);
      
    <span class="c1">// now loop through and read all the responses</span>
    <span class="k">for</span> (<span class="kt">int</span> i=<span class="m">0</span>; i&lt;<span class="m">400</span>; i++)
      <span class="nf">read_http_response</span>(socks[i]);
  }
}
</pre></div>

<p>
Like other tests, this test code takes care to send the http get requests to lots of different sockets
before attempting to read responses from any of them to force the server to perform context switches
form one connection to another.  But it is also trying to avoid performing operations like constructing
custom GET messages for each request.  While not explicily shown in this example, it also does only minimal
parsing of the response message.  Also not really shown, but the client uses keep-alive strategies for the
connection to avoid timing the process of the connect itself.  This sort of test is trying to only ensure
that the server is switching connections and parsing the http request prior to sending its reply.
</p>

<p>
What follows is the look of the source for these simple "echo" servers written in the different tool
sets that are timed.  Following that is the table listing the timings.
</p>

<h4>
The Anon Example
</h4>

<p>
The anon example gets to use anon-style syntax and looks like this.  The <b>http_server</b> class is
one provided by anon, and its constructor takes a callable function that is called - in a fiber - each
time a new connection is established from a client.  The style of its API is inspired by the node.js
syntax for this.  In this example it simply specifies that it will be returning plain text, and then
writes "echo server!" into the body of the reply.
</p>

<div class="highlight highlight-C++"><pre>
<span class="kt">http_server</span> my_http(/*port*/8080,
    [](<span class="kt">http_server::pipe_t</span>& pipe, <span class="kc">const</span> <span class="kt">http_request</span>& request){
      <span class="kt">http_response</span> response;
      response.<span class="nf">add_header</span>(<span class="s2">&quot;Content-Type&quot;</span>, <span class="s2">&quot;text/plain&quot;</span>);
      response &lt;&lt; <span class="s2">&quot;echo server!\n&quot;</span>;
      pipe.<span class="nf">respond</span>(response);
    });
</pre></div>

<h4>
The Node.js Example
</h4>

<p>
The node.js example is visually very similar to the anon one.  It makes use of syntax that lets it pass
a function as a parameter to an http server.  That service calls the supplied function when new connections
arrive, and it is the function that writes the response information.  But in this case the lauguage is javascript,
not C++
</p>

<div class="highlight highlight-C++"><pre>
my_http = <span class="nf">require</span>(<span class="s2">&quot;http&quot;</span>);
my_http.<span class="nf">createServer</span>(<span class="kc">function</span>(request,response){
  response.<span class="nf">writeHeader</span>(200, {<span class="s2">&quot;Content-Type&quot;</span>: <span class="s2">&quot;text/plain&quot;</span>});
  response.<span class="nf">write</span>(<span class="s2">&quot;echo server!&quot;</span>);
  response.<span class="nf">end</span>();
}).<span class="nf">listen</span>(/*port*/8080); 
</pre></div>

<h4>
The Proxygen Example
</h4>

<p>
The proxygen example is too complicated to show in a short code snippet like the
anon and node.js examples.  However, it is just the standard "echo" server that comes with the
<a href="https://github.com/facebook/proxygen">proxygen</a>
github project and the one that Facebook talks about in
<a href="https://code.facebook.com/posts/1503205539947302/introducing-proxygen-facebook-s-c-http-framework">
public discussions</a>.  You can see the code in their
<a href="https://github.com/facebook/proxygen/blob/master/proxygen/httpserver/samples/echo/EchoHandler.h">
EchoHandler.h</a> and
<a href="https://github.com/facebook/proxygen/blob/master/proxygen/httpserver/samples/echo/EchoHandler.cpp">
EchoHandler.cpp</a> files.  In this design, proxygen supplies a base
class named 
<a href="https://github.com/facebook/proxygen/blob/master/proxygen/httpserver/RequestHandler.h">RequestHandler</a>
that defines a number of virtual methods with names like <b>onRequest</b> and <b>onBody</b>.  <b>EchoHandler</b>
is a subclass of this and implements those virtual methods with simple echoing behavior.
</p>

<h4>
The Spring 4 Example
</h4>

<p>
<a href="http://spring.io">Spring</a> is a Java framework somewhat similar to Java EE.  It has recently been
updated to version 4.0.  This version comes with a number of example projects that one can build.  One of these
is an example of how to build a RESTful server.  Although simpler than the Proxygen example, it is still a
little too complicated to show in a short code snippet.  But it is simple enough to serve as a fair comparison
to the "echo" servers we are testing here.  The source code for this Spring example can be found in github
<a href="https://github.com/spring-guides/gs-rest-service">here.</a>  The design of this example server makes
use of Java's support for "annotations" to provide much of the wiring that routes an HTTP GET request for
"/greeting" to the code shown in the
<a href="https://github.com/spring-guides/gs-rest-service/blob/master/complete/src/main/java/hello/GreetingController.java">
GreetingController.java</a> class.
</p>

<p>
To run this Spring example we modify the <b>http_client</b> example code slightly so that it requests "/greeting"
instead of "/" in the HTTP GET request. We also modify it so that the Accept header specifies "application/json"
(which is what this particular server is designed to return).  As explained above, the <b>http_client</b> application
specifies the HTTP "keep-alive" behavior, but unlike the other servers tested here which keep the connection open during
the entire test, the Spring server closes it every 100 api calls.  So there is a slight penalty reported
by this test because it has to reconnect every 100 calls.  There is also a very significant "warm up" period
when the server is first started, causing the first execution of <b>http_client</b> to be measurably slower
than subsequent executions.  In the numbers reported below we discard the first run of <b>http_client</b>
and then only report the next 3.
</p>

<h4>
The Comparison Numbers
</h4>

<p>
The table below is displayed in "messages per second" as seen by the <b>http_client</b> application, described above.
Like in other tests, the client application is running on the same machine as the server, and so is using the
loopback network address to connect to and communicate with the server.  The testing code uses http's "keep-alive"
strategy on the sockets, so these numbers do not include connect/shutdown time on the sockets themselves (other
than the Spring 4 numbers as described above).  Particularly in the 1 core case, that one core is forced to run
both the client and server threads.  This code is run in an Ubuntu 14.04 VM, running in VMWare on a 2.3 GHz MacBook
Pro laptop.  There is variability in the numbers from one run to the next.  This table represents three consecutive
runs, listing the slowest and fastest of those three.
</p>

<p>
<table style="width:100%">
  <caption><b>Messages Per Second</b></caption>
  <tr>
    <td></td>
    <td><b>1 Core</b></td>
    <td><b>2 Cores</b></td>
    <td><b>4 Cores</b></td>
  </tr>
  <tr>
    <td><b>Anon</b></td>
    <td>84,500 - 85,900</td>
    <td>163,200 - 168,000</td>
    <td>264,000 - 274,000</td>
  </tr>
  <tr>
    <td><b>Proxygen</b></td>
    <td>47,400 - 51,300</td>
    <td>86,200 - 91,000</td>
    <td>120,500 - 124,300</td>
  </tr>
  <tr>
    <td><b>Spring 4</b></td>
    <td>9,193 - 9,472</td>
    <td>19,544 - 19,913</td>
    <td>26,550 - 26,716</td>
  </tr>
  <tr>
    <td><b>Node.js</b></td>
    <td>4,868 - 5,317</td>
    <td>5,150 - 5,223</td>
    <td>5,169 - 5,182</td>
  </tr>
</table>
</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/pkholland/anon/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/pkholland/anon/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/pkholland/anon"></a> is maintained by <a href="https://github.com/pkholland">pkholland</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
